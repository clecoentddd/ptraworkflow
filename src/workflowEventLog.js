import workflowF from './workflowRules';
import { automatePaymentPlanCreation } from './paymentPlan/paymentPlanAutomation';
import { paymentTransactionF } from './paymentTransaction/paymentTransactionF';

// workflowEventLog.js
// EventZ Workflow Checklist: Event Log implementation
// Stores and retrieves the append-only event log for workflow steps in localStorage

const WORKFLOW_EVENT_LOG_KEY = 'eventz_workflow_event_log';

// Read the event log from localStorage (returns array of events)
export function readWorkflowEventLog() {
  const raw = localStorage.getItem(WORKFLOW_EVENT_LOG_KEY);
  if (!raw) return [];
  try {
    return JSON.parse(raw);
  } catch (e) {
    return [];
  }
}

// Write the event log to localStorage
function writeWorkflowEventLog(events) {
  localStorage.setItem(WORKFLOW_EVENT_LOG_KEY, JSON.stringify(events));
}



// Append one or more events to the log (with auto-timestamp and F function)
export function appendWorkflowEvents(newEvents) {
  const now = new Date().toISOString();
  let events = readWorkflowEventLog();
  const toAppend = Array.isArray(newEvents) ? newEvents : [newEvents];
  let allStamped = [];
  function appendAndRunF(evts, parentChangeId = null) {
    for (const e of evts) {
      // Propagate changeId from parent if not present
      let stamped = { ...e, timestamp: e.timestamp || now };
      if (parentChangeId && !stamped.changeId) {
        stamped.changeId = parentChangeId;
      }
      // Patch PaymentPlanAutoGenerated event with missing paymentPlanId
      if (stamped.event === 'PaymentPlanAutoGenerated' && !stamped.paymentPlanId) {
        if (typeof window !== 'undefined' && window.crypto && window.crypto.randomUUID) {
          stamped.paymentPlanId = window.crypto.randomUUID();
        } else {
          stamped.paymentPlanId = require('uuid').v4();
        }
      }

      // Payment transaction F: enforce only one PaiementEffectué per transactionId
      let paymentFEvents = [];
      if (stamped.event === 'PaiementEffectué') {
        paymentFEvents = paymentTransactionF(events, stamped);
        if (paymentFEvents && paymentFEvents.length > 0) {
          // If rejected, do not append the payment event, only the rejection
          events = events.concat(paymentFEvents);
          allStamped.push(...paymentFEvents);
          continue;
        }
      }

      events = events.concat([stamped]);
      allStamped.push(stamped);
      // Run F(Y, e) and append any resulting events recursively
      const fEvents = workflowF(events, stamped);
      if (fEvents && fEvents.length > 0) {
        // Pass down changeId from triggering event
        appendAndRunF(fEvents, stamped.changeId);
      }
      // Only run payment plan automation for newly appended events that are DecisionValidee
      if (stamped.event === 'DecisionValidee') {
        const autoEvents = automatePaymentPlanCreation(events);
        if (autoEvents && autoEvents.length > 0) {
          appendAndRunF(autoEvents, stamped.changeId);
        }
      }
    }
  }
  appendAndRunF(toAppend, toAppend[0]?.changeId);
  writeWorkflowEventLog(events);
  return allStamped;
}

// Clear the event log (for testing/dev only)
export function clearWorkflowEventLog() {
  localStorage.removeItem(WORKFLOW_EVENT_LOG_KEY);
}

const workflowEventLog = {
  readWorkflowEventLog,
  appendWorkflowEvents,
  clearWorkflowEventLog,
};
export default workflowEventLog;
