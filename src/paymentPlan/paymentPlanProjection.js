// paymentPlanProjection.js
// Pure projection functions for payment plan state
import { PAYMENT_PLAN_CREATED, PAYMENT_PLAN_AUTO_GENERATED } from './paymentPlanEvents';
import { getLatestValidatedDecision } from '../valideDecision/valideDecisionProjection';

/**
 * Computes the current payment plan state from the event log.
 * Returns: {
 *   paymentPlanId,
 *   changeId,
 *   planDeCalculId,
 *   payments: Array<{ month, amount }>,
 *   isAutoGenerated: boolean
 * }
 */

export function getPaymentPlanStates(eventLog) {
  // Returns all payment plans, including decisionId
  // Patch any PaymentPlanAutoGenerated event with null paymentPlanId
  return eventLog
    .filter(e => e.event === PAYMENT_PLAN_CREATED || e.event === PAYMENT_PLAN_AUTO_GENERATED)
    .map(e => {
      let paymentPlanId = e.paymentPlanId;
      if (e.event === PAYMENT_PLAN_AUTO_GENERATED && !paymentPlanId) {
        if (typeof window !== 'undefined' && window.crypto && window.crypto.randomUUID) {
          paymentPlanId = window.crypto.randomUUID();
        } else {
          paymentPlanId = require('uuid').v4();
        }
      }
      return {
        paymentPlanId,
        changeId: e.changeId,
        planDeCalculId: e.planDeCalculId,
        decisionId: e.decisionId,
        payments: e.payments || [],
        isAutoGenerated: e.event === PAYMENT_PLAN_AUTO_GENERATED,
  timestamp: e.timestamp,
      };
    });
}

// For backward compatibility, return the latest payment plan

export function getPaymentPlanState(eventLog) {
  // Use latest validated decision for payments
  const latestDecision = getLatestValidatedDecision(eventLog);
  if (!latestDecision) return null;
  // Find latest payment plan
  const allPlans = eventLog.filter(e => e.event === 'PaymentPlanCreated' || e.event === 'PaymentPlanAutoGenerated');
  const latestPlan = allPlans.length > 0 ? allPlans[allPlans.length - 1] : null;
  // If decision references a non-latest paymentPlanId, log error
  if (latestPlan && latestDecision.paymentPlanId !== latestPlan.paymentPlanId) {
    // Check if error already exists
    const errorId = `decision-plan-mismatch-${latestDecision.decisionId}`;
    const alreadyLogged = eventLog.some(e => e.event === 'ErrorLog' && e.errorId === errorId);
    if (!alreadyLogged) {
      // Append error event
      eventLog.push({
        event: 'ErrorLog',
        errorId,
        message: `Decision references outdated paymentPlanId (${latestDecision.paymentPlanId}), expected latest (${latestPlan.paymentPlanId})`,
  timestamp: new Date().toISOString(),
      });
      // Optionally, trigger alert/notification in UI
    }
    // Only log once per decisionId
  }
  // Extract payments from DecisionValidee payload (array of { month, toPayOrReimburse })
  const payments = Array.isArray(latestDecision.payload)
    ? latestDecision.payload.map(p => ({ month: p.month, amount: p.toPayOrReimburse }))
    : [];

  // If latestDecision.paymentPlanId is null, use latest PaymentPlanAutoGenerated event's paymentPlanId
  let paymentPlanId = latestDecision.paymentPlanId;
  if (!paymentPlanId) {
    const latestAutoPlan = allPlans.reverse().find(e => e.event === 'PaymentPlanAutoGenerated' && e.paymentPlanId);
    if (latestAutoPlan) paymentPlanId = latestAutoPlan.paymentPlanId;
  }
  return {
    paymentPlanId,
    changeId: latestDecision.changeId,
    planDeCalculId: latestDecision.planDeCalculId,
    decisionId: latestDecision.decisionId,
    payments,
    isAutoGenerated: true,
  timestamp: latestDecision.timestamp,
  };
}

/**
 * Returns true if a payment plan exists for the given changeId.
 */
export function hasPaymentPlan(eventLog, changeId) {
  return eventLog.some(e =>
    (e.event === PAYMENT_PLAN_CREATED || e.event === PAYMENT_PLAN_AUTO_GENERATED) &&
    e.changeId === changeId
  );
}
