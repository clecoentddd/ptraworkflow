
// PaymentPlanPage.js
// Displays the current payment plan using event-sourced projections
import React, { useState } from 'react';
import '../layout.css';
import ProcessFlowStatusBar from '../sharedProjections/ProcessFlowStatusBar';
import { readWorkflowEventLog } from '../workflowEventLog';
import { getPaymentPlanState } from './paymentPlanProjection';
import EventStream from '../components/EventStream';
import { getPaymentTransactions } from './paymentTransactionProjection';
import { createPaiementDemandeEvent, createPaiementEffectueEvent } from './paymentTransactionSlice';
import { appendWorkflowEvents } from '../workflowEventLog';

export default function PaymentPlanPage() {
  const [refresh, setRefresh] = useState(0);
  const [popup, setPopup] = useState(null);
  const eventLog = readWorkflowEventLog();
  const paymentPlanProjection = getPaymentPlanState(eventLog);
  // Use planDeCalculId as fallback if paymentPlanId is null
  const paymentPlan = paymentPlanProjection ? {
    ...paymentPlanProjection,
    paymentPlanId: paymentPlanProjection.paymentPlanId || paymentPlanProjection.planDeCalculId
  } : null;
  // Transaction state is now event-sourced
  const [showProjection, setShowProjection] = useState(false);

  // Helper: get last day of month
  function getLastDayOfMonth(monthStr) {
    const [yyyy, mm] = monthStr.split('-').map(Number);
    return new Date(yyyy, mm, 0); // day 0 of next month = last day of month
  }

  // Handler for payment
  function handlePay(month, amount) {
    if (amount < 0) {
      console.log(`[Rembourser] Attempt for month: ${month}, amount: ${amount}`);
    }
    // Invariant check: block if already paid/reimbursed for this month
    const transactionsForMonth = getPaymentTransactions(eventLog).filter(t => t.month === month && t.paymentPlanId === paymentPlan.paymentPlanId);
    const alreadySettled = transactionsForMonth.some(t => t.status === 'Effectué' || t.status === 'Remboursé');
    if (alreadySettled) {
      setPopup(`Cette transaction pour le mois ${month} a déjà été effectuée.`);
      console.log(`[Invariant] Transaction for month ${month} already settled.`);
      return;
    }
    // Always generate new UUIDs for transactionId and paymentPlanId
    let transactionId, newPaymentPlanId;
    if (typeof window !== 'undefined' && window.crypto && window.crypto.randomUUID) {
      transactionId = window.crypto.randomUUID();
      newPaymentPlanId = window.crypto.randomUUID();
    } else {
      transactionId = require('uuid').v4();
      newPaymentPlanId = require('uuid').v4();
    }
    // ...existing code...
    const dueDate = getLastDayOfMonth(month).toISOString();
    // For reimbursement, use negative amount in PaiementEffectué
    const isReimbursement = amount < 0;
    const demandeEvent = createPaiementDemandeEvent({
      transactionId,
      paymentPlanId: newPaymentPlanId,
      month,
      dueDate,
      amount
    });
    console.log(`[Rembourser] Appending PaiementDemandé event:`, demandeEvent);
    appendWorkflowEvents(demandeEvent);
    const effectueEvent = createPaiementEffectueEvent({
      transactionId,
      paymentPlanId: newPaymentPlanId,
      month,
      amount: isReimbursement ? amount : amount
    });
    console.log(`[Rembourser] Appending PaiementEffectué event:`, effectueEvent);
    appendWorkflowEvents(effectueEvent);
    setTimeout(() => setRefresh(r => r + 1), 100); // force re-render after event
  }

  const today = new Date();
  const transactions = getPaymentTransactions(eventLog).filter(t => t.paymentPlanId === paymentPlan.paymentPlanId);

  // EventStream filter: PaymentPlanAutoGenerated and PaiementEffectué events for this plan
  const eventStreamFilter = e => (
    (e.event === 'PaymentPlanAutoGenerated' &&
      (e.changeId === paymentPlan.changeId || e.planDeCalculId === paymentPlan.planDeCalculId)) ||
    (e.event === 'PaiementEffectué' && e.paymentPlanId === paymentPlan.paymentPlanId)
  );

  if (!paymentPlan) {
    return (
      <div>No payment plan available.</div>
    );
  }

  return (
    <>
      {popup && (
        <div style={{ position: 'fixed', top: 40, left: '50%', transform: 'translateX(-50%)', background: '#fff', color: '#222', border: '1px solid #d32f2f', borderRadius: 8, padding: '16px 32px', zIndex: 9999, boxShadow: '0 2px 8px rgba(0,0,0,0.15)' }}>
          <span>{popup}</span>
          <button style={{ marginLeft: 24, background: '#d32f2f', color: '#fff', border: 'none', borderRadius: 4, padding: '4px 12px', cursor: 'pointer' }} onClick={() => setPopup(null)}>Fermer</button>
        </div>
      )}
      <div className="workflow-main-container">
  <ProcessFlowStatusBar />
        <div className="event-stream-section" style={{ position: 'relative' }}>
          <h2>Payment Plan</h2>
          <div style={{ marginBottom: 18 }}>
            <strong>Change ID:</strong> {paymentPlan.changeId}<br />
            <strong>Plan de Calcul ID:</strong> {paymentPlan.planDeCalculId}<br />
            <strong>Payment Plan ID:</strong> {paymentPlan.paymentPlanId}<br />
            <strong>Type:</strong> {paymentPlan.isAutoGenerated ? 'Auto-generated (created by automation)' : 'Manual (created by user)'}
          </div>
          <button
            className="projection-btn"
            onClick={() => setShowProjection(s => !s)}
          >
            {showProjection ? 'Masquer Projection' : 'Afficher Projection'}
          </button>
          {showProjection && (
            <div className="projection-popup">
              <button className="projection-close-btn" onClick={() => setShowProjection(false)}>
                Fermer
              </button>
              <pre style={{ background: '#222', color: '#fff', padding: 16, borderRadius: 8, fontSize: 13, marginBottom: 18 }}>
                {JSON.stringify(paymentPlanProjection, null, 2)}
              </pre>
            </div>
          )}

          <style>{`
            .plan-de-calcul-calc-btn {
              background: #2d7ef7;
              color: #fff;
              border: none;
              border-radius: 4px;
              padding: 6px 16px;
              cursor: pointer;
              transition: background 0.2s;
            }
            .plan-de-calcul-calc-btn:hover {
              background: #1a5fc2;
            }
            .plan-de-calcul-calc-btn:active {
              background: #174a8c;
            }
          `}</style>
          <table className="workflow-table" style={{ marginTop: '1rem' }}>
            <thead>
              <tr>
                <th>Month</th>
                <th>Amount</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody>
              {paymentPlan.payments.map(({ month, amount }) => {
                // Only consider payment events after the latest payment plan timestamp
                const planTs = new Date(paymentPlan.ts).getTime();
                // Aggregate all transactions for this month and plan
                const transactionsForMonth = getPaymentTransactions(eventLog).filter(t => t.month === month && t.paymentPlanId === paymentPlan.paymentPlanId);
                const alreadySettled = transactionsForMonth.some(t => t.status === 'Effectué' || t.status === 'Remboursé');
                let actionLabel = '';
                let showButton = false;
                let buttonText = '';
                if (alreadySettled) {
                  // Find the latest transaction for this month
                  const latestTx = transactionsForMonth[transactionsForMonth.length - 1];
                  if (latestTx && latestTx.status === 'Effectué' && amount > 0) {
                    actionLabel = 'Payé';
                  } else if (latestTx && latestTx.status === 'Remboursé' && amount < 0) {
                    actionLabel = 'Remboursé';
                  } else {
                    actionLabel = 'Transaction effectuée';
                  }
                  showButton = false;
                } else if (amount > 0) {
                  actionLabel = `A payer (${amount})`;
                  showButton = true;
                  buttonText = 'Payer';
                } else if (amount < 0) {
                  actionLabel = `À rembourser (${Math.abs(amount)})`;
                  showButton = true;
                  buttonText = 'Rembourser';
                } else {
                  actionLabel = 'Rien à faire';
                }
                // Only allow payment/reimbursement for months prior to the current month
                const [year, mon] = month.split('-').map(Number);
                const now = new Date();
                const currentYear = now.getFullYear();
                const currentMonth = now.getMonth() + 1; // JS months are 0-based
                const isPastMonth = (year < currentYear) || (year === currentYear && mon < currentMonth);
                return (
                  <tr key={month}>
                    <td>{month}</td>
                    <td>{amount}</td>
                    <td>
                      {showButton && isPastMonth ? (
                        <button onClick={() => handlePay(month, amount)} className="plan-de-calcul-calc-btn">{buttonText}</button>
                      ) : actionLabel}
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
        {/* EventStream outside the main container */}
        <EventStream
          events={eventLog}
          filter={eventStreamFilter}
          maxHeight={400}
          showTitle={true}
        />
      </div>
    </>
  );
}
