// useReconciliationValidation.js
// React hook for reconciliation validation logic
import { useState, useMemo } from 'react';
import computeDroitsPeriod from '../droits/projections/computeDroitsPeriod';
import { readWorkflowEventLog, appendWorkflowEvents } from '../workflowEventLog';
import { getDeltaPerMonth, isDecisionValidated } from './reconciliationProjection';
import { createDecisionValideeEvent } from './reconciliationEvents';

export function useReconciliationValidation() {
  const [eventLog, setEventLog] = useState(() => readWorkflowEventLog());
  const {
    deltaPerMonth,
    calculationId,
    changeId,
    paymentPlanId: directPaymentPlanId
  } = useMemo(() => getDeltaPerMonth(eventLog), [eventLog]);

  // Always show the latest paymentPlanId if not directly linked
  let paymentPlanId = directPaymentPlanId;
  if (!paymentPlanId) {
    const latest = [...eventLog].reverse().find(e => e.event === "PaymentPlanCreated" || e.event === "PaymentPlanAutoGenerated");
    paymentPlanId = latest?.paymentPlanId || null;
  }
  const alreadyValidated = useMemo(() => isDecisionValidated(eventLog), [eventLog]);

  function validate() {
    // All business logic is in the projection
  // Allow generating the decision again, do not block if alreadyValidated
    if (!calculationId || !changeId) return false;
    // Build payments per month from latestCalculated if deltaPerMonth is empty
    let paymentsPerMonth = Object.entries(deltaPerMonth || {}).map(([month, amount]) => ({ month, amount }));
    if (paymentsPerMonth.length === 0) {
      // fallback to latestCalculated
      paymentsPerMonth = Object.entries(latestCalculated).map(([month, amount]) => ({ month, amount }));
    }
    const event = createDecisionValideeEvent({
      changeId,
      planDeCalculId: calculationId,
      paymentPlanId: paymentPlanId || null,
      deltaPerMonth,
      payments: paymentsPerMonth
    });
    appendWorkflowEvents(event);
    return true;
  }

  // Use only the latest PlanDeCalculEffectué event for all months
  const latestCalcEvent = [...eventLog].reverse().find(e => e.event === "PlanDeCalculEffectué");
  const latestCalculated = {};
  let calcId = null;
  let chgId = null;
  // Get latest droits period from all events
  let droitsPeriod = computeDroitsPeriod(eventLog);
  if (latestCalcEvent) {
    calcId = latestCalcEvent.calculationId || null;
    chgId = latestCalcEvent.changeId || null;
    latestCalcEvent.payload.ressources.forEach(res => {
      latestCalculated[res.month] = res.amount;
    });
  }
  // Sum all PaiementEffectué events per month
  const latestPaid = {};
  eventLog.forEach(e => {
    if (e.event === "PaiementEffectué") {
      if (!latestPaid[e.month]) latestPaid[e.month] = 0;
      latestPaid[e.month] += Number(e.amount) || 0;
    }
  });
  const allMonths = Array.from(new Set([...Object.keys(latestCalculated), ...Object.keys(latestPaid)])).sort();
  const reconciliationPayload = allMonths.map(month => ({
    month,
    calculatedAmount: latestCalculated[month] || 0,
    amountPaid: latestPaid[month] || 0,
    toPayOrReimburse: (latestCalculated[month] || 0) - (latestPaid[month] || 0
    )
  }));
  const reconciliation = {
    changeId: chgId,
    planDeCalculId: calcId,
    paymentPlanId,
    droitsPeriod,
    payload: reconciliationPayload
  };

  return {
    reconciliation,
    deltaPerMonth,
    calculationId: calcId,
    changeId: chgId,
    paymentPlanId,
    droitsPeriod,
    alreadyValidated,
    validate,
    eventLog,
  };
}
